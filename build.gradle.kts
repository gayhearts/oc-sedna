import java.nio.file.Files
import java.nio.file.attribute.PosixFilePermission
import java.io.File
import java.util.regex.Pattern 

// Minecraft info.
var minecraft_version = extra["minecraft_version"]
var minecraft_sdk     = extra["minecraft_sdk"]

// Dependency version info.
var opencomputers_version = extra["opencomputers_version"]

var ceres_version         = extra["ceres_version"]

var sedna_version         = extra["sedna_version"]
var sedna_commit_ref      = extra["sedna_commit_ref"]

var minux_version         = extra["minux_version"]

// Repositories for dependencies.
var ceres_repo = extra["ceres_repo"]
var sedna_repo = extra["sedna_repo"]
var minux_repo = extra["minux_repo"]

// List of output files obtained during reobfJar.
var output_list: MutableList<String> = mutableListOf<String>()

plugins {
	id("org.gradlex.reproducible-builds") version "1.1"
	id("com.falsepattern.fpgradle-mc") version "3.3.0"
	id("com.gradleup.shadow") version "9.3.0"
	id("java")
}

group = "gayhearts"

java.toolchain{
	languageVersion.set(JavaLanguageVersion.of(25))
}

repositories {
	maven("https://maven.minecraftforge.net/")
	maven("https://cursemaven.com")

	maven {
		name = "GTNH Maven"
		url = uri("https://nexus.gtnewhorizons.com/repository/public/")
	}

	mavenCentral()
	listOf("${sedna_repo}", "${minux_repo}", "${ceres_repo}").forEach{repo ->
		maven {
			url = uri("https://maven.pkg.github.com/${repo}")
			credentials {
				username = project.findProperty("gpr.user") as String? ?: System.getenv("GPR_USER")
				password = project.findProperty("gpr.key") as String? ?: System.getenv("GPR_KEY")
			}
		}
	}
}

dependencies {
	implementation("com.github.GTNewHorizons:OpenComputers:${opencomputers_version}:api")
	implementation("com.github.GTNewHorizons:OpenComputers:${opencomputers_version}:dev")

	implementation("li.cil.ceres:ceres:${ceres_version}")
	implementation("li.cil.sedna:sedna:${sedna_version}")
	implementation("li.cil.sedna:sedna-buildroot:${minux_version}")

	shadowImplementation("li.cil.ceres:ceres:${ceres_version}")
	shadowImplementation("li.cil.sedna:sedna:${sedna_version}")
	shadowImplementation("li.cil.sedna:sedna-buildroot:${minux_version}")
}

minecraft_fp {
	java {
		//Valid values: legacy, jvmDowngrader, modern
		compatibility        = modern                                 //Convention: legacy
		version              = JavaVersion.VERSION_25                 //Convention, determined by compatibility
		vendor               = JvmVendorSpec.ADOPTIUM                      //Convention
		modernRuntimeVersion = JavaVersion.VERSION_25       //Convention, determined by compatibility
		//        //Valid values: doNotShade, projectIsLgpl21PlusCompatible, iWillPublishTheUnshadedJarForLgpl21PlusCompliance
		jvmDowngraderShade   = doNotShade                      //Convention
		//        jvmDowngraderShadePackage = minecraft_fp.mod.rootPkg //Convention
	}

	mod {
		modid   = "ocsedna"   //REQUIRED
		name    = "OpenComputersSedna"  //REQUIRED
		//        version = "autogenerated from git" //Convention
		rootPkg = "$group.ocsedna" //REQUIRED
	}

	tokens {
		tokenClass = "Tags"
		tokenClassIgnoreRootPkg = false         //Convention
		modid                   = "MOD_ID"      //Convention
		name                    = "MOD_NAME"    //Convention
		version                 = "MOD_VERSION" //Convention
		rootPkg                 = "ROOT_PKG"    //Convention
	}

	// Use this if you want to publish on maven/curse/modrinth
	publish {
		//        // optional
		//        // Enabled by default, makes your mod jars more reproducible between rebuilds if the source code didn't change
		reproducibleJars = true //Convention
	}

	//optional
	//For configuring the fpgradle update checker
	updates {
		check = false // Convention: true
	}
}

tasks.reobfJar {
    // Store paths of any files we get during reobfuscation.
    getOutputs().getFiles().forEach { file: File ->
        output_list.add(file.toString())
    }
}

tasks.register<Jar>("finalJar") {
    dependsOn("reobfJar")
    archiveClassifier = "repack"
    
    from({
        // Extract and utilize files from jar paths stored during reobfJar.
        output_list.map { zipTree(it) }
    })

    doLast {
        getOutputs().getFiles().forEach {file: File ->
            // Regex to remove archive classifier from filename.
            val regex_pattern = Pattern.compile("(.+)-repack(.+)")
            val output_file = regex_pattern.matcher(file.toString()).replaceAll("$1$2")
        
            // Move file to the regex result.
            file.renameTo(file(output_file))
        }
    }
}

tasks.build {
    dependsOn("finalJar")
}

tasks.shadowJar {
	mergeServiceFiles()
	dependencies {
		include(dependency("li.cil.ceres:ceres:${ceres_version}"))
		include(dependency("li.cil.sedna:sedna:${sedna_version}"))
		include(dependency("li.cil.sedna:sedna-buildroot:${minux_version}"))
	}
}

tasks.withType<AbstractArchiveTask>().configureEach {
	isPreserveFileTimestamps = false
	isReproducibleFileOrder = true

	eachFile {
		permissions {
			val isExec =
			Files.getPosixFilePermissions(file.toPath()).contains(PosixFilePermission.OWNER_EXECUTE)
			unix(if (isExec) "755" else "644")
		}
	}
	dirPermissions { unix("755") }
}

tasks.compileJava {
	options.compilerArgs.addAll(listOf("-Xlint:all", "-Werror"))
}
