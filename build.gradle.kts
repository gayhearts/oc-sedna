import java.nio.file.Files
import java.nio.file.attribute.PosixFilePermission
import java.io.File
import java.util.regex.Pattern

// For downloading and checksumming files.
import java.net.URL
import java.net.URI
import java.nio.channels.Channels
import java.nio.channels.ReadableByteChannel
import java.io.FileOutputStream
import java.security.MessageDigest
import java.math.BigInteger

// Log4j
var log4j_version: String by extra

// OpenComputersSedna info
var modId: String by extra
var modGroup: String by extra

// Minecraft info.
var minecraft_version = extra["minecraft_version"]
var minecraft_sdk     = extra["minecraft_sdk"]

// Dependency version info.
var opencomputers_version = extra["opencomputers_version"]

var ceres_version         = extra["ceres_version"]

var sedna_version         = extra["sedna_version"]
var sedna_commit_ref      = extra["sedna_commit_ref"]

var minux_version         = extra["minux_version"]

// Repositories for dependencies.
var ceres_repo = extra["ceres_repo"]
var sedna_repo = extra["sedna_repo"]
var minux_repo = extra["minux_repo"]

var opensbi_repo    = extra["opensbi_repo"]
var opensbi_hash    = extra["opensbi_hash"]
var opensbi_version = extra["opensbi_version"]

var fw_jump_hash:    String by extra
var fw_dynamic_hash: String by extra

// List of output files obtained during reobfJar.
var output_list: MutableList<String> = mutableListOf<String>()

plugins {
	id("org.gradlex.reproducible-builds") version "1.1"
	id("com.falsepattern.fpgradle-mc") version "3.3.0"
	id("com.gradleup.shadow") version "9.3.0"
	id("io.freefair.compress.trees") version "9.2.0"
	id("java")
	id("pmd")

	// Check dependencies for vulnerabilities.
	id("org.owasp.dependencycheck") version "12.2.0" apply false
}

allprojects {
    apply(plugin = "org.owasp.dependencycheck")
}

configure<org.owasp.dependencycheck.gradle.extension.DependencyCheckExtension> {
    format = org.owasp.dependencycheck.reporting.ReportGenerator.Format.ALL.toString()
}

var group = extra["modGroup"]

java.toolchain{
	languageVersion.set(JavaLanguageVersion.of(25))
}

configure<PmdExtension> {
    // toolVersion = "7.0.0-rc4"
    isIgnoreFailures = false
    toolVersion = "7.21.0"
    sourceSets = setOf(project.sourceSets.getByName("main"))
    ruleSetFiles = files(
		"pmd.xml"
	)
}

tasks.withType<Pmd> {
    reports {
	xml.required.set(true)
	html.required.set(true)
    }
}

tasks.named("pmdTest") {
    enabled = false
}
 
repositories {
	maven("https://maven.minecraftforge.net/")
	maven("https://cursemaven.com")

	maven {
		name = "GTNH Maven"
		url = uri("https://nexus.gtnewhorizons.com/repository/public/")
	}

	mavenCentral()
	listOf("${sedna_repo}", "${minux_repo}", "${ceres_repo}").forEach{repo ->
		maven {
			url = uri("https://maven.pkg.github.com/${repo}")
			credentials {
				username = project.findProperty("gpr.user") as String? ?: System.getenv("GPR_USER")
				password = project.findProperty("gpr.key") as String? ?: System.getenv("GPR_KEY")
			}
		}
	}
}

dependencies {
	implementation("com.github.GTNewHorizons:OpenComputers:${opencomputers_version}:api")
	implementation("com.github.GTNewHorizons:OpenComputers:${opencomputers_version}:dev")

	implementation("li.cil.ceres:ceres:${ceres_version}")
	implementation("li.cil.sedna:sedna:${sedna_version}")
	implementation("li.cil.sedna:sedna-buildroot:${minux_version}")

	implementation("org.tukaani:xz:1.11")

	// For logging. ENSURE UP TO DATE.
	implementation("org.apache.logging.log4j:log4j-api:${log4j_version}")

	shadowImplementation("li.cil.ceres:ceres:${ceres_version}")
	shadowImplementation("li.cil.sedna:sedna:${sedna_version}")
	shadowImplementation("li.cil.sedna:sedna-buildroot:${minux_version}")
}

fun getGitRef(): String {
	try {
		var stdout = providers.exec {
		  commandLine("git", "rev-parse", "--short", "HEAD")
		}.standardOutput.asText.get()

		return stdout.toString().trim()
	} catch (ignored: Throwable) {
		return "unknown"
	}
}

var build_ref: String = getGitRef()

minecraft_fp {
	version = "${build_ref}"

	java {
		//Valid values: legacy, jvmDowngrader, modern
		compatibility        = modern                                 //Convention: legacy
		version              = JavaVersion.VERSION_25                 //Convention, determined by compatibility
		vendor               = JvmVendorSpec.ADOPTIUM                      //Convention
		modernRuntimeVersion = JavaVersion.VERSION_25       //Convention, determined by compatibility
		//        //Valid values: doNotShade, projectIsLgpl21PlusCompatible, iWillPublishTheUnshadedJarForLgpl21PlusCompliance
		jvmDowngraderShade   = doNotShade                      //Convention
		//        jvmDowngraderShadePackage = minecraft_fp.mod.rootPkg //Convention
	}

	mod {
		modid   = "ocsedna"   //REQUIRED
		name    = "OpenComputersSedna"  //REQUIRED
		//        version = "autogenerated from git" //Convention
		rootPkg = "$group.ocsedna" //REQUIRED
	}

	tokens {
		tokenClass = "Tags"
		tokenClassIgnoreRootPkg = false         //Convention
		modid                   = "MOD_ID"      //Convention
		name                    = "MOD_NAME"    //Convention
		version                 = "MOD_VERSION" //Convention
		rootPkg                 = "ROOT_PKG"    //Convention
	}

	// Use this if you want to publish on maven/curse/modrinth
	publish {
		//        // optional
		//        // Enabled by default, makes your mod jars more reproducible between rebuilds if the source code didn't change
		reproducibleJars = true //Convention

		maven {
			artifact = "${modId}"
		}
	}

	//optional
	//For configuring the fpgradle update checker
	updates {
		check = false // Convention: true
	}
}


// TODO: Move sha512sum and DownloadFile to their own file? sub-project?
fun sha512sum(filepath: String, comparison_hash: String): Boolean {
	try {
		val sha512: MessageDigest = MessageDigest.getInstance("SHA-512")

		val checked_file: File = File(filepath)
		val digested: ByteArray = sha512.digest(Files.readAllBytes(checked_file.toPath()))
		val hash: String = String.format("%0128x", BigInteger(1, digested))

		if( hash == comparison_hash ) {
			return true
		} else {
			throw GradleException(String.format("sha512sum: ERROR: \"%s\" doesn't match hash of \"%s\n", hash, comparison_hash))
			return false
		}
	} catch (thrown: Throwable) {
		System.out.println(thrown.toString())
		return false
	}
}

fun DownloadFile(fileurl: String, output: String): Boolean {
	try {
		// Read from URL into a temporary file.
		val src_url: URL = URI.create(fileurl).toURL()
		val byte_channel: ReadableByteChannel = Channels.newChannel(src_url.openStream())

		val outstream: FileOutputStream = FileOutputStream(output)
		outstream.getChannel().transferFrom(byte_channel, 0, Long.MAX_VALUE)
	} catch (thrown: Throwable) {
		System.out.println(thrown.toString())
		return false
	}


	if (File("${output}").isFile()) {
		return true
	} else {
		return false
	}
}

tasks.register("OpenSBI") {
	val opensbi_filename: String = "opensbi-${opensbi_version}-rv-bin.tar.xz"
	val opensbi_url:      String = "https://github.com/${opensbi_repo}/releases/download/v${opensbi_version}/${opensbi_filename}"

	// tmp that exist during OpenSBI.
	val tmp_dir:     String = getTemporaryDir().toString()
	val tarball:     String = "${tmp_dir}/${opensbi_filename}"

	// Where we want to put everything.
	val build_dir:   String = project.layout.buildDirectory.get().toString()
	val out_dir:     String = "${build_dir}/resources/main/assets/ocsedna"

	// Attempt download.
	if( DownloadFile(opensbi_url, tarball) == false ){
		throw GradleException(String.format("ERROR: Unable to download file from \"%s\" to \"%s\".\n", opensbi_url, tarball))
	}

	if( sha512sum(tarball, "${opensbi_hash}") == true ){
		// Extract the OpenSBI tarball.
		copy {
			from(commonsCompress.tarXzTree(tarball))

			// Just extract certain .bin files, don't keep directories.
			include("**/lp64/generic/firmware/fw_jump.bin")
			include("**/lp64/generic/firmware/fw_dynamic.bin")
			eachFile {
				relativePath = RelativePath(true, *relativePath.segments.drop(6).toTypedArray())
			}
			includeEmptyDirs = false

			into(tmp_dir)
		}

		// If the .bin file sums succeed.
		if( sha512sum("${tmp_dir}/fw_jump.bin", fw_jump_hash) && sha512sum("${tmp_dir}/fw_dynamic.bin", fw_dynamic_hash) ) {
			copy {
				from(fileTree(tmp_dir))

				include("**/fw_jump.bin")
				include("**/fw_dynamic.bin")

				into("${out_dir}/binary/")
			}
		} else {
			throw GradleException("ERROR: opensbi .bin files don't match their hashes.")
		}
	} else {
		throw GradleException("ERROR: opensbi tarball doesn't match it's hash.")
	}
}

tasks.reobfJar {
	// Store paths of any files we get during reobfuscation.
	getOutputs().getFiles().forEach { file: File ->
		output_list.add(file.toString())
	}
}

tasks.register<Jar>("finalJar") {
	dependsOn("reobfJar")
	dependsOn("OpenSBI")
	archiveClassifier = "repack"

	from({
		// Extract and utilize files from jar paths stored during reobfJar.
		output_list.map { zipTree(it) }
	})

	from("src/main/resources/assets/binary") {
		include("fw_jump.bin");
		include("fw_dynamic.bin")
	}

	doLast {
		getOutputs().getFiles().forEach {file: File ->
			// Regex to remove archive classifier from filename.
			val regex_pattern = Pattern.compile("(.+)-repack(.+)")
			val output_file = regex_pattern.matcher(file.toString()).replaceAll("$1$2")

			// Move file to the regex result.
			file.renameTo(file(output_file))
		}
	}
}

tasks.build {
	dependsOn("finalJar")
}

tasks.shadowJar {
	mergeServiceFiles()
	dependencies {
		include(dependency("li.cil.ceres:ceres:${ceres_version}"))
		include(dependency("li.cil.sedna:sedna:${sedna_version}"))
		include(dependency("li.cil.sedna:sedna-buildroot:${minux_version}"))
	}
}

tasks.withType<AbstractArchiveTask>().configureEach {
	isPreserveFileTimestamps = false
	isReproducibleFileOrder = true

	eachFile {
		permissions {
			val isExec =
			Files.getPosixFilePermissions(file.toPath()).contains(PosixFilePermission.OWNER_EXECUTE)
			unix(if (isExec) "755" else "644")
		}
	}
	dirPermissions { unix("755") }
}

tasks.compileJava {
	options.compilerArgs.addAll(listOf("-Xlint:all", "-Werror"))
}
